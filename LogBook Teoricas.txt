Conceitos gerais:

PI T - 2 mar
- Conceito de memória:

int maximo (int a, int b){
if (a>b) return a;
else return b;

// return a>b ? a:b;

// if (x>y) y = x;
//return y;
}

- Pretende-se uma função que calcula o max e o min e que os retorna para o main, consoante o que se queira.
- Há comunicação com a main, quando na main é chamada a nossa função.
- Podiamos criar um struct com um par de numeros e esta função retornava esse par.
- Em máquina, cada variável está num endereço em memória.
- Com esta informação podemos criar apontadores para cada variável.
- & x : sendo x uma variável, significa o endereço de memoria onde está guardado x.
- * a : sendo a um endereço de memória, significa o conteúdo da memória no endereço a.

//SEM APONTADORES
void maxMin (int a, int b){
int t;
if (x<y) {
t = x;
x = y;
y = t;

}

//COM APONTADORES
void maxMin (int *a, int *b){
int t;
if (x<y) {
t = *x;
*x = *y;
*y = t;

}

int main(){
int x = 3, y = 6, z;
int *a;

/*
a = & x; o a passa a apontar para o endereço do x.
(*a)++; //ir ao conteúdo de a e incrementar em 1.
z = *a; //o z passa a ser o conteúdo de a.

//z= maximo(x,y)
*/

maxMin (&x,&y);
printf ("%d %d\n", x,y);
return 0;
}

- Invocação de uma função: leva a aque se crie uma nova zona memória para a função que é chamada!
- Vamos empilhando na stack estas zonas de memória. Quando deixamos de precisar da função, regressamos ao ponto onde
estavamos do main e a zona de memória acaba por "desaparecer", não tendo acesso a ela.
- O nome das variáveis não está em causa, pois há cópia de valores do main para a função, as duas funções até podem
ter as variáveis iguais, mas elas só têm nomes iguais, de resto continuam diferentes!!
- Assim, aquilo que uma função chamada recebe são VALORES, CÓPIAS.
- A estratégia na troca de valores é guardar numa variável temporario o valor de um deles.
- Há uma função swap que é muito conhecida por fazer isso, mas com apontadores.
- Ao usarmos apontadores, os valores são alterados na própria função!!
- A outra função apenas vai mexer nas coisas que estão a ser apontadas!


PI T - 4 mar
- Introdução aos arrays. Os arrays são constituidos por vários elementos, onde cada índice ou posição é acedida atráves
de um número começado na posição 0, sempre.
- Se a dimensão de um array é 10, temos posições de 0 a 9.
- A contagem é feito sempre no final do ciclo.
- índices num array: i = N-1.
- Quando definimos um array, temos de definir obrigatoriamente a dimensão deste array, ou seja, quando este se declara.
- Se não dissermos a dimensão do array, o C pode calcular e determinar através da sintaxe:

    y[]={1,2,3,4,5,6,7,8,9} // dimensão 10

- Função que copia array:

    -> É um procedimento, não calcula nada, só funciona!

void copiaArray (int destino[], int origem[], int N) {
    for (int i = 0; i<10 ; i++) destino[i] = origem[i];
    return;
}

-> Note-se que na função anterior, quando passamos os arrays, não estamos a passar efetivamente o array, mas sim,
um apontador para a primeira posição do array, passando o seu endereço!
-> É escusado dizermos que array(&a,&b), pois o b já é por si um endereço, não sendo preciso voltar a especificá-lo.

int main() {
    int i, y [10] = {1,2,3,4,5,6,7,8,9,10}, b[10];
    int *p;
    int a;
    a = 42;
    p = a; // p fica com 42, mas 42 não é um endereço válido
    p = &a; // p fica a apontar para o endereço apontado por a
    p = b; // p fica a apontar para o endereço b

    copiaArray(b,y, 10);
    return 0;
}

/* Em C um array é o endereço da sua primeira componente, ou seja, o que guardamos no y é de facto o endereço já!!
 * Os arrays são endereços!!!!
 */